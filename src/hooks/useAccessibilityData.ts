import { useState, useEffect, useCallback } from 'react';
import type { ScanSummary, PageData, AccessibilityResult } from '@/types/accessibility';

// Use Vite's base URL to support GitHub Pages deployment
const BASE_URL = import.meta.env.BASE_URL || '/';
const RESULTS_BASE_URL = `${BASE_URL}results`.replace('//', '/');

export interface DayFolder {
  name: string; // Unique identifier: folder + summary file
  folder: string; // The actual folder name for path building
  displayName: string;
  date: Date;
  summaryFile: string;
}

interface ManifestEntry {
  folder: string;
  summary: string;
}

// Parse timestamp from summary filename like "summary_2025-12-02T17-51-10.242Z.json"
function parseSummaryTimestamp(summaryFileName: string): Date | null {
  // Extract timestamp: summary_2025-12-02T17-51-10.242Z.json
  const match = summaryFileName.match(/summary_(\d{4}-\d{2}-\d{2})T(\d{2})-(\d{2})-(\d{2})\.(\d{3})Z\.json/);
  if (!match) return null;
  
  const [, datePart, hours, minutes, seconds, ms] = match;
  // Reconstruct ISO timestamp: 2025-12-02T17:51:10.242Z
  const isoString = `${datePart}T${hours}:${minutes}:${seconds}.${ms}Z`;
  const date = new Date(isoString);
  return isNaN(date.getTime()) ? null : date;
}

// Format Date for display with time like "Tuesday, Dec 2, 2025 at 5:51 PM"
function formatDisplayDateWithTime(date: Date): string {
  return date.toLocaleDateString('en-US', {
    weekday: 'long',
    month: 'short',
    day: 'numeric',
    year: 'numeric',
    hour: 'numeric',
    minute: '2-digit',
  });
}

export function useAvailableDays() {
  const [days, setDays] = useState<DayFolder[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const loadDays = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      const foundDays: DayFolder[] = [];

      // Try to fetch manifest file first (generated by update-results.sh)
      try {
        const manifestResponse = await fetch(`${RESULTS_BASE_URL}/manifest.json`);
        if (manifestResponse.ok) {
          const manifest: ManifestEntry[] = await manifestResponse.json();
          if (Array.isArray(manifest)) {
            for (const entry of manifest) {
              if (typeof entry === 'object' && entry.folder && entry.summary) {
                // Try to parse timestamp from summary filename first
                const summaryDate = parseSummaryTimestamp(entry.summary);
                const folderDate = parseDayFolderName(entry.folder);
                const date = summaryDate || folderDate;
                
                if (date) {
                  // Use summary file as part of unique identifier
                  const uniqueName = `${entry.folder}::${entry.summary}`;
                  foundDays.push({
                    name: uniqueName,
                    folder: entry.folder,
                    displayName: summaryDate 
                      ? formatDisplayDateWithTime(summaryDate) 
                      : formatDisplayDate(date),
                    date,
                    summaryFile: entry.summary,
                  });
                }
              } else if (typeof entry === 'string') {
                // Backwards compatibility with simple string array
                const date = parseDayFolderName(entry);
                if (date) {
                  foundDays.push({
                    name: entry,
                    folder: entry,
                    displayName: formatDisplayDate(date),
                    date,
                    summaryFile: '', // Will need to be discovered
                  });
                }
              }
            }
          }
        }
      } catch {
        // Manifest doesn't exist or is invalid
      }

      // Fallback: try to detect today's folder by checking if it exists
      if (foundDays.length === 0) {
        const today = new Date();
        const todayFolder = formatDayFolderName(today);
        try {
          // Check if today's folder exists
          const checkResponse = await fetch(`${RESULTS_BASE_URL}/${todayFolder}/`, { method: 'HEAD' });
          if (checkResponse.ok) {
            foundDays.push({
              name: todayFolder,
              folder: todayFolder,
              displayName: formatDisplayDate(today),
              date: today,
              summaryFile: '', // Will need to be discovered
            });
          }
        } catch {
          // Today's folder doesn't exist
        }
      }

      // Sort by date, most recent first
      foundDays.sort((a, b) => b.date.getTime() - a.date.getTime());
      setDays(foundDays);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to discover day folders');
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    loadDays();
  }, [loadDays]);

  return { days, loading, error, refresh: loadDays };
}

// Parse folder name like "Tue_Dec_02_2025" to Date
function parseDayFolderName(name: string): Date | null {
  const parts = name.split('_');
  if (parts.length !== 4) return null;

  const [_dayOfWeek, month, day, year] = parts;
  const monthMap: Record<string, number> = {
    Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5,
    Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11,
  };

  const monthNum = monthMap[month];
  if (monthNum === undefined) return null;

  const date = new Date(parseInt(year), monthNum, parseInt(day));
  return isNaN(date.getTime()) ? null : date;
}

// Format Date to folder name like "Tue_Dec_02_2025"
function formatDayFolderName(date: Date): string {
  const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  
  const dayOfWeek = days[date.getDay()];
  const month = months[date.getMonth()];
  const dayNum = String(date.getDate()).padStart(2, '0');
  const year = date.getFullYear();
  
  return `${dayOfWeek}_${month}_${dayNum}_${year}`;
}

// Format Date for display like "Tuesday, Dec 2, 2025"
function formatDisplayDate(date: Date): string {
  return date.toLocaleDateString('en-US', {
    weekday: 'long',
    month: 'short',
    day: 'numeric',
    year: 'numeric',
  });
}

export function useAccessibilityData(selectedFolder: string | null, summaryFileName?: string) {
  const [summary, setSummary] = useState<ScanSummary | null>(null);
  const [pages, setPages] = useState<PageData[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const getDayBasePath = useCallback(() => {
    return selectedFolder ? `${RESULTS_BASE_URL}/${selectedFolder}` : RESULTS_BASE_URL;
  }, [selectedFolder]);

  const loadSummary = useCallback(async () => {
    if (!selectedFolder) {
      setLoading(false);
      return;
    }

    try {
      setLoading(true);
      setError(null);

      const basePath = getDayBasePath();
      let summaryFile = summaryFileName || '';

      // If no summary file name provided, try to discover it
      if (!summaryFile) {
        // Try to find summary file by checking the manifest
        try {
          const manifestResponse = await fetch(`${RESULTS_BASE_URL}/manifest.json`);
          if (manifestResponse.ok) {
            const manifest: ManifestEntry[] = await manifestResponse.json();
            const entry = manifest.find(e => typeof e === 'object' && e.folder === selectedFolder);
            if (entry && entry.summary) {
              summaryFile = entry.summary;
            }
          }
        } catch {
          // Ignore manifest errors
        }
      }

      if (!summaryFile) {
        throw new Error('No summary file found for this date');
      }

      // Load the summary
      const summaryResponse = await fetch(`${basePath}/${summaryFile}`);
      if (!summaryResponse.ok) {
        throw new Error('Failed to load summary file');
      }
      const summaryData: ScanSummary = await summaryResponse.json();
      setSummary(summaryData);

      // Build page data from summary
      // The label now represents the nested path like "tailwindcss.com/index" or "tailwindcss.com/docs/installation/using-vite"
      const pageDataList: PageData[] = await Promise.all(
        summaryData.pageScanSummary.map(async (page) => {
          // Convert label to file paths - label is like "tailwindcss.com/index"
          const jsonFile = `${page.label}.json`;
          const pngFile = `${page.label}.png`;
          
          // Check if screenshot exists
          let screenshotFile: string | undefined;
          try {
            const pngResponse = await fetch(`${basePath}/${pngFile}`, { method: 'HEAD' });
            if (pngResponse.ok) {
              screenshotFile = pngFile;
            }
          } catch {
            // Screenshot doesn't exist
          }

          return {
            label: page.label,
            jsonFile,
            screenshotFile,
            counts: page.counts,
          };
        })
      );

      setPages(pageDataList);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
    } finally {
      setLoading(false);
    }
  }, [selectedFolder, summaryFileName, getDayBasePath]);

  useEffect(() => {
    loadSummary();
  }, [loadSummary]);

  const loadPageResults = useCallback(async (jsonFile: string): Promise<AccessibilityResult[]> => {
    const basePath = getDayBasePath();
    const response = await fetch(`${basePath}/${jsonFile}`);
    if (!response.ok) {
      throw new Error(`Failed to load page results: ${jsonFile}`);
    }
    const data = await response.json();
    return data.results || [];
  }, [getDayBasePath]);

  const getScreenshotUrl = useCallback((screenshotFile: string) => {
    const basePath = getDayBasePath();
    return `${basePath}/${screenshotFile}`;
  }, [getDayBasePath]);

  return {
    summary,
    pages,
    loading,
    error,
    loadPageResults,
    getScreenshotUrl,
    refresh: loadSummary,
  };
}

export function usePageResults(jsonFile: string | null, selectedFolder: string | null) {
  const [results, setResults] = useState<AccessibilityResult[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!jsonFile || !selectedFolder) {
      setResults([]);
      return;
    }

    const load = async () => {
      try {
        setLoading(true);
        setError(null);
        const basePath = `${RESULTS_BASE_URL}/${selectedFolder}`;
        const response = await fetch(`${basePath}/${jsonFile}`);
        if (!response.ok) {
          throw new Error(`Failed to load: ${jsonFile}`);
        }
        const data = await response.json();
        setResults(data.results || []);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
        setResults([]);
      } finally {
        setLoading(false);
      }
    };

    load();
  }, [jsonFile, selectedFolder]);

  return { results, loading, error };
}
